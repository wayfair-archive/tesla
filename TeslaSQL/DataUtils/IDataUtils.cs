using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using System.Data.SqlClient;
using System.Data;

namespace TeslaSQL.DataUtils {
    public interface IDataUtils {
        /// <summary>
        /// Gets information on the last CT batch relevant to this agent
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="agentType">We need to query a different table for master vs. slave</param>
        /// <param name="slaveIdentifier">Hostname of the slave if applicable</param>
        DataRow GetLastCTBatch(string dbName, AgentType agentType, string slaveIdentifier = "");

        /// <summary>
        /// Gets CT versions that are greater than the passed in CTID and have the passed in bitwise value
        /// </summary>
        /// <param name="dbName">Database name to check</param>
        /// <param name="CTID">Pull CTIDs greater than this one</param>
        /// <param name="syncBitWise">Only include versions containing this bit</param>
        DataTable GetPendingCTVersions(string dbName, Int64 CTID, int syncBitWise);

        DataTable GetPendingCTSlaveVersions(string dbName, string slaveIdentifier, int bitwise);

        /// <summary>
        /// Gets the start time of the last successful CT batch before the specified CTID
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="CTID">Current CTID</param>
        /// <param name="syncBitWise">syncBitWise value to compare against</param>
        /// <returns>Datetime representing last succesful run</returns>
        DateTime GetLastStartTime(string dbName, Int64 CTID, int syncBitWise, AgentType type, string slaveIdentifier = null);

        /// <summary>
        /// Gets the CHANGE_TRACKING_CURRENT_VERSION() for a database
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <returns>Current change tracking version</returns>
        Int64 GetCurrentCTVersion(string dbName);

        /// <summary>
        /// Gets the minimum valid CT version for a table
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="table">Table name</param>
        /// <param name="schema">Table's schame</param>
        /// <returns>Minimum valid version</returns>
        Int64 GetMinValidVersion(string dbName, string table, string schema);

        /// <summary>
        /// Creates a new row in tblCTVersion
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="syncStartVersion">Version number the batch starts at</param>
        /// <param name="syncStopVersion">Version number the batch ends at</param>
        /// <returns>CTID generated by the database</returns>
        ChangeTrackingBatch CreateCTVersion(string dbName, Int64 syncStartVersion, Int64 syncStopVersion);

        /// <summary>
        /// Generates and runs SELECT INTO query to create a changetable
        /// </summary>
        /// <returns>Int representing the number of rows affected (number of changes captured)</returns>
        int SelectIntoCTTable(string sourceCTDB, TableConf table, string sourceDB, ChangeTrackingBatch batch, int timeout, long? startVersionOverride = null);

        /// <summary>
        /// Creates a row in tblCTSlaveVersion
        /// </summary>
        /// <param name="dbName">Database name to write to</param>
        /// <param name="slaveIdentifier">Slave identifier string (usually hostname)</param>
        /// <param name="ctb">Change tracking batch</param>
        void CreateSlaveCTVersion(string dbName, ChangeTrackingBatch ctb, string slaveIdentifier);

        /// <summary>
        /// Create the tblCTSchemaChange_(version) table on the relay server, dropping if it already exists
        /// </summary>
        /// <param name="dbName">Database to run on</param>
        /// <param name="CTID">CT version number</param>
        void CreateSchemaChangeTable(string dbName, Int64 CTID);

        /// <summary>
        /// Get DDL events from tblDDLEvent that occurred after the specified date
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="afterDate">Date to start from</param>
        /// <returns>DataTable object representing the events</returns>
        DataTable GetDDLEvents(string dbName, DateTime afterDate);

        /// <summary>
        /// Writes a schema change record to the appropriate schema change table
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="CTID">Batch ID</param>
        /// <param name="schemaChange">Schema change object to write to the database</param>
        void WriteSchemaChange(string dbName, Int64 CTID, SchemaChange schemaChange);

        /// <summary>
        /// Gets a column's data type
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="table">Table name</param>
        /// <param name="schema">The table's schema</param>
        /// <param name="column">Column name to get the data type of</param>
        /// <returns>DataRow representing the data type</returns>
        DataRow GetDataType(string dbName, string table, string schema, string column);

        /// <summary>
        /// Updates the syncStopVersion in tblCTVersion to the specified value for the specified CTID
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="syncStopVersion">New syncStopVersion</param>
        /// <param name="CTID">Batch identifier</param>
        void UpdateSyncStopVersion(string dbName, Int64 syncStopVersion, Int64 CTID);

        /// <summary>
        /// Check to see if a table exists on the specified server
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="table">Table name to check for</param>
        /// <param name="schema">Table's schema</param>
        /// <returns>Boolean representing whether or not the table exists.</returns>
        bool CheckTableExists(string dbName, string table, string schema = "dbo");

        /// <summary>
        /// Compares two tables and retrieves a column list that is an intersection of the columns they contain
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="table1">First table</param>
        /// <param name="schema1">First table's schema</param>
        /// <param name="table2">Second table (order doesn't matter)</param>
        /// <param name="schema2">Second table's schema</param>
        /// <returns>String containing the resulting intersect column list</returns>
        IEnumerable<string> GetIntersectColumnList(string dbName, string table1, string schema1, string table2, string schema2);

        /// <summary>
        /// Check whether a table has a primary key
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="table">First table</param>
        /// <param name="schema">Schema name</param>
        /// <returns>True if the table has a primary key, otherwise false</returns>
        bool HasPrimaryKey(string dbName, string table, string schema);

        /// <summary>
        /// Checks to see if a table exists on the specified server and drops it if so.
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="table">Table name</param>
        /// <param name="schema">Table's schema</param>
        /// <returns>Boolean specifying whether or not the table existed</returns>
        bool DropTableIfExists(string dbName, string table, string schema);

        /// <summary>
        /// Gets a dictionary of columns for a table
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="table">Table name</param>
        /// <param name="schema">Table's schema</param>
        /// <returns>Dictionary with column name as key and a bool representing whether it's part of the primary key as value.</returns>
        Dictionary<string, bool> GetFieldList(string dbName, string table, string schema);

        /// <summary>
        /// Adds the specified bit to the syncBitWise column in tblCTVersion/tblCTSlaveVersion
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="CTID">CT version number</param>
        /// <param name="value">Bit to add</param>
        /// <param name="agentType">Agent type running this request (if it's slave we use tblCTSlaveVersion)</param>
        void WriteBitWise(string dbName, Int64 CTID, int value, AgentType agentType);

        /// <summary>
        /// Gets syncbitwise for specified CT version table
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="CTID">CT version number to check</param>
        /// <param name="agentType">Agent type running this request (if it's slave we use tblCTSlaveVersion)</param>
        int ReadBitWise(string dbName, Int64 CTID, AgentType agentType);

        /// <summary>
        /// Marks a CT batch as complete
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="CTID">CT batch ID</param>
        /// <param name="syncStopTime">Stop time to write</param>
        /// <param name="slaveIdentifier">For slave agents, the slave hostname or ip</param>
        void MarkBatchComplete(string dbName, Int64 CTID, DateTime syncStopTime, string slaveIdentifier);

        /// <summary>
        /// Pulls the list of schema changes for a CTID
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="CTID">change tracking batch ID</param>
        /// <returns>DataTable object containing the query results</returns>
        DataTable GetSchemaChanges(string dbName, Int64 CTID);

        /// <summary>
        /// Gets the rowcounts for a table
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="table">Table name</param>
        /// <param name="schema">Table's schema</param>
        /// <returns>The number of rows in the table</returns>
        Int64 GetTableRowCount(string dbName, string table, string schema);

        /// <summary>
        /// Checks whether change tracking is enabled on a table
        /// </summary>
        /// <param name="dbName">Database name</param>
        /// <param name="table">Table name</param>
        /// <param name="schema">Table's schema</param>
        /// <returns>True if it is enabled, false if it's not.</returns>
        bool IsChangeTrackingEnabled(string dbName, string table, string schema);

        /// <summary>
        /// Logs an error to the database. These errors are intended to be picked up and emailed out wholesale, to avoid spam.
        /// </summary>
        /// <param name="message">error to log</param>
        void LogError(string message);

        /// <summary>
        /// Returns a list of errors that have not been marked sent
        /// </summary>
        /// <returns>DataTable containing at least the fields "CelError" and "CelId"</returns>
        DataTable GetUnsentErrors();

        /// <summary>
        /// Marks as sent the errors corresponding to the passed in list of IDs.
        /// </summary>
        void MarkErrorsSent(IEnumerable<int> celIds);

        /// <summary>
        /// Renames a column in a table, and the associated history table if recording history is configured
        /// <summary>
        /// <param name="t">TableConf object for the table</param>
        /// <param name="dbName">Database name the table lives in</param>
        /// <param name="schema">Schema the table is part of</param>
        /// <param name="table">Table name</param>
        /// <param name="columnName">Old column name</param>
        /// <param name="newColumnName">New column name</param>
        void RenameColumn(TableConf t, string dbName, string schema, string table, string columnName, string newColumnName);

        /// <summary>
        /// Changes a column's data type
        /// </summary>
        /// <param name="t">TableConf object for the table</param>
        /// <param name="dbName">Database name the table lives in</param>
        /// <param name="schema">Schema the table is part of</param>
        /// <param name="table">Table name</param>
        /// <param name="columnName">Column name to modify</param>
        /// <param name="dataType">String representation of the column's new data type</param>
        void ModifyColumn(TableConf t, string dbName, string schema, string table, string columnName, string dataType);

        /// <summary>
        /// Adds a column to a table
        /// </summary>
        /// <param name="t">TableConf object for the table</param>
        /// <param name="dbName">Database name the table lives in</param>
        /// <param name="schema">Schema the table is part of</param>
        /// <param name="table">Table name</param>
        /// <param name="columnName">Column name to add</param>
        /// <param name="dataType">String representation of the column's data type</param>
        void AddColumn(TableConf t, string dbName, string schema, string table, string columnName, string dataType);

        /// <summary>
        /// Drops a column from a table
        /// </summary>
        /// <param name="t">TableConf object for the table</param>
        /// <param name="dbName">Database name the table lives in</param>
        /// <param name="schema">Schema the table is part of</param>
        /// <param name="table">Table name</param>
        /// <param name="columnName">Column name to drop</param>
        void DropColumn(TableConf t, string dbName, string schema, string table, string columnName);

        /// <summary>
        /// Creates and does not populate TableInfo table for this CT batch in the appropriate DB
        /// </summary>
        void CreateTableInfoTable(string dbName, Int64 CTID);
        /// <summary>
        /// Publishes TableInfo to the appropriate TableInfo for this CT batch.
        /// </summary>
        /// <param name="table">Must have its field lists populated</param>
        /// <param name="expectedRows">Number of rows the slaves should expect to insert from this batch</param>
        void PublishTableInfo(string dbName, TableConf table, long CTID, long expectedRows);

        /// <summary>
        /// Applies the actual table changes from the CT table in CTDBName to the table passed in, and, if given, the archive table as well.
        /// </summary>
        /// <param name="table">Table to apply changes to</param>
        /// <param name="archiveTable">Archive table - if null, no archiving is done</param>
        RowCounts ApplyTableChanges(TableConf table, TableConf archiveTable, string dbName, Int64 ctid, string CTDBName);

        /// <summary>
        /// Consolidates batches. Used when a slave has too many batches to process one at a time.
        /// </summary>
        /// <param name="ctTableName">name of the original CT table</param>
        /// <param name="consolidatedTableName">name of the new consolidated table</param>
        void Consolidate(string ctTableName, string consolidatedTableName, string dbName, string schemaName);

        /// <summary>
        /// Used to de-dupe rows in consolidated CT tables
        /// </summary>
        void RemoveDuplicatePrimaryKeyChangeRows(TableConf table, string consolidatedTableName, string dbName);

        /// <summary>
        /// copies data from the table t into the appropriate History table, creating it if it does not exist.
        /// </summary>
        void CopyIntoHistoryTable(ChangeTable t, string slaveCTDB);

        /// <summary>
        /// Gets the change track batch associated with the given CTID.
        /// </summary>
        ChangeTrackingBatch GetCTBatch(string dbName, Int64 ctid);

        /// <summary>
        /// Used to revert a CT batch to say that nothing has been done, if errors occurred that are solved best by restarting.
        /// </summary>
        void RevertCTBatch(string dbName, Int64 ctid);

        /// <summary>
        /// Merges the table from the sourceDB into the corresponding merged table in the destDB
        /// </summary>
        void MergeCTTable(TableConf table, string destDB, string sourceDB, Int64 CTID);

        /// <summary>
        /// In sharded solutions, the shards have to have their batches coordinated. 
        /// This method is creates a new version for a shard, so that the shard doesn't need to be aware that it is a part of sharding
        /// except that it knows not to create new versions for itself.
        /// </summary>
        /// <param name="db">Shard's DB</param>
        /// <param name="startVersion">the change tracking version for this batch</param>
        void CreateShardCTVersion(string db, long ctid, Int64 startVersion);

        /// <summary>
        /// The primary keys for tables are not defined in their corresponding change tables, for reasons of performance and consolidation,
        /// so in order to merge correctly, we need these lists defined elsewhere. These are defined in "info tables" for each batch,
        /// and this method returns the primary key columns.
        /// </summary>
        IEnumerable<string> GetPrimaryKeysFromInfoTable(TableConf table, long CTID, string database);

        /// <summary>
        /// Tallies the total amount of expected rows from all the tables in the change tracking batch corresponding to the specified CTID.
        /// </summary>
        int GetExpectedRowCounts(string ctDbName, long ctid);


        /// <summary>
        /// Returns all tables in the given DB
        /// </summary>
        IEnumerable<TTable> GetTables(string dbName);

        /// <summary>
        /// This is actually run on the Relay, but returns a list of CTIDs started before chopDate
        /// </summary>
        /// <param name="chopDate">Cut-off date. Batches started before this will be eliminated.</param>
        IEnumerable<long> GetOldCTIDsMaster(string dbName, DateTime chopDate);
        /// <summary>
        /// Gets the CTIDs that the relay maintenance agent has determined need to go
        /// </summary>
        /// <param name="chopDate">Cut-off date. Batches finished before this time will be eliminated.</param>
        /// <returns></returns>
        IEnumerable<long> GetOldCTIDsRelay(string dbName, DateTime chopDate);
        /// <summary>
        /// This is actually run on the Relay, but it gets CTIDs that are safe to drop for a slave
        /// </summary>
        /// <param name="chopDate">Cut-off date. Batches finished before this time will be eliminated</param>
        /// <param name="slaveIdentifier">The hostname of this slave.</param>
        IEnumerable<long> GetOldCTIDsSlave(string dbName, DateTime chopDate, string slaveIdentifier);

        /// <summary>
        /// Deletes CT Versions completed before chopDate
        /// </summary>
        void DeleteOldCTVersions(string dbName, DateTime chopDate);
        /// <summary>
        /// Deletes Slave CT Versions completed before chopDate
        /// </summary>
        void DeleteOldCTSlaveVersions(string dbName, DateTime chopDate);

        /// <summary>
        /// Checks if the given table is currently being initialized. Tables being initialized should not be processed.
        /// </summary>
        bool IsBeingInitialized(string sourceCTDB, TableConf table);

        /// <summary>
        /// If the table has a row in the initialization table, this returns the change tracking version indicated there.
        /// </summary>
        long? GetInitializeStartVersion(string sourceCTDB, TableConf table);

        /// <summary>
        /// Deletes rows from the initialization table. This should be called after a successful run to make sure we don't 
        /// use the overrides in the initialization table more than once.
        /// </summary>
        void CleanUpInitializeTable(string dbName, DateTime syncStartTime);

        /// <summary>
        /// Gets a DataTable of ChangeTables that have >0 rows for a list of batches
        /// </summary>
        DataTable GetTablesWithChanges(string dbName, IList<ChangeTrackingBatch> batches);

        /// <summary>
        /// Marks as complete all of the batches corresponding to the ctids passed in
        /// associated with the given slaveIdentifier
        /// </summary>
        void MarkBatchesComplete(string dbName, IEnumerable<long> ctids, DateTime syncStopTime, string slaveIdentifier);
        
        /// <summary>
        /// Gets a list of all columns for the table confs passed in.
        /// </summary>
        /// <param name="tableConfCTTableName">A map from a TableConf to the corresponding CT table to query.</param>
        Dictionary<TableConf, IList<string>> GetAllFields(string dbName, Dictionary<TableConf, string> tableConfCTTableName);

        /// <summary>
        /// Gets a list of all the primary keys for each of the tables passed in.
        /// </summary>
        /// <param name="batch">The batch of the appropriate Info table to use.</param>
        Dictionary<TableConf, IList<string>> GetAllPrimaryKeys(string dbName, IEnumerable<TableConf> tables, ChangeTrackingBatch batch);
    }
    public struct TTable {
        public readonly string name;
        public readonly string schema;
        public TTable(string name, string schema) {
            this.name = name;
            this.schema = schema;
        }
    }
}
